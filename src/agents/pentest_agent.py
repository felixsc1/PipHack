"""
LangGraph Agent for Penetration Testing Workflow
"""

import os
from typing import TypedDict, Annotated, Sequence, List
from operator import add

from dotenv import load_dotenv
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder
from langchain_openai import ChatOpenAI
from langgraph.graph import END, StateGraph
from langgraph.prebuilt import create_react_agent

from tools.nmap_tool import nmap_scan
from tools.searchsploit_tool import search_exploit
from tools.web_enum_tool import enumerate_web_application

# Load environment variables
load_dotenv()

# Initialize the LLM
llm = ChatOpenAI(
    model="gpt-4-turbo-preview",
    temperature=0.1,
    api_key=os.getenv("OPENAI_API_KEY")
)

# Define the tools available to the agent
tools = [nmap_scan, search_exploit, enumerate_web_application]


class AgentState(TypedDict):
    """State for the penetration testing agent."""
    messages: Annotated[Sequence[BaseMessage], add]
    scan_results: dict  # Store scan results for reference
    current_target: str  # Current target being analyzed
    next_action: str  # Next recommended action


def create_pentest_agent():
    """
    Create a LangGraph agent for penetration testing workflows.

    Returns:
        Compiled LangGraph for the pentesting agent
    """

    system_prompt = """You are PipHack, an intelligent penetration testing assistant designed to help security professionals and ethical hackers perform comprehensive security assessments.

Your capabilities include:
- Network scanning and service enumeration using nmap
- Vulnerability research using searchsploit (local Exploit-DB)
- Web application enumeration and analysis using browser automation

WORKFLOW GUIDELINES:
1. When a user requests to scan or analyze a target, start with nmap to discover open ports and services
2. For each discovered service, use searchsploit to check for known exploits
3. If web services (HTTP/HTTPS) are found, use web enumeration to analyze the web application
4. Always provide clear explanations of what you're doing and why
5. Suggest next steps based on findings, but let the user decide on exploitation
6. Store results in a structured way for reference

TOOL USAGE:
- Use nmap_scan when you need to discover open ports and services on a target
- Use search_exploit when you want to find known vulnerabilities for specific services/versions
- Use enumerate_web_application when analyzing web applications for potential vulnerabilities

RESPONSE STYLE:
- Be professional and security-focused
- Explain technical concepts clearly
- Highlight potential security risks
- Provide actionable recommendations
- Never attempt actual exploitation without explicit user permission

Always maintain ethical hacking principles and remind users to only test systems they have permission to assess."""

    # Create the prompt template with system message
    prompt = ChatPromptTemplate.from_messages([
        ("system", system_prompt),
        ("placeholder", "{messages}"),
    ])

    # Create the agent using create_react_agent
    agent = create_react_agent(
        llm,
        tools,
        prompt=prompt
    )

    return agent


def create_custom_pentest_graph():
    """
    Create a custom LangGraph with more control over the pentesting workflow.

    Returns:
        Compiled LangGraph for structured pentesting workflow
    """

    def agent_node(state: AgentState):
        """Main agent node that processes user input and decides on actions."""
        messages = state["messages"]
        agent = create_pentest_agent()

        # Process through the agent
        result = agent.invoke({"messages": messages})

        # Extract the last message (agent's response)
        last_message = result["messages"][-1]

        return {
            "messages": [last_message],
            "scan_results": state.get("scan_results", {}),
            "current_target": state.get("current_target", ""),
            "next_action": "continue"
        }

    def should_continue(state: AgentState):
        """Determine if the workflow should continue or end."""
        # For now, always continue (user can end conversation)
        return "continue"

    # Create the graph
    workflow = StateGraph(AgentState)

    # Add nodes
    workflow.add_node("agent", agent_node)

    # Add edges
    workflow.set_entry_point("agent")
    workflow.add_conditional_edges(
        "agent",
        should_continue,
        {
            "continue": "agent",
            "end": END
        }
    )

    # Compile the graph
    graph = workflow.compile()

    return graph


# Create instances for import
pentest_agent = create_pentest_agent()
pentest_graph = create_custom_pentest_graph()


def run_pentest_query(query: str, target: str = "") -> dict:
    """
    Run a penetration testing query through the agent.

    Args:
        query: User's question or request
        target: Optional target specification

    Returns:
        Agent response with results
    """
    initial_state = {
        "messages": [HumanMessage(content=query)],
        "scan_results": {},
        "current_target": target,
        "next_action": "start"
    }

    # Use the simpler agent for now
    result = pentest_agent.invoke(initial_state)

    return result